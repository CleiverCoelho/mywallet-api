/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 7.0.8
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */

"use strict";var rangesPush=(()=>{var y=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var V=Object.getOwnPropertyNames,A=Object.getOwnPropertySymbols;var w=Object.prototype.hasOwnProperty,I=Object.prototype.propertyIsEnumerable;var b=(n,r,i)=>r in n?y(n,r,{enumerable:!0,configurable:!0,writable:!0,value:i}):n[r]=i,p=(n,r)=>{for(var i in r||(r={}))w.call(r,i)&&b(n,i,r[i]);if(A)for(var i of A(r))I.call(r,i)&&b(n,i,r[i]);return n};var j=(n,r)=>{for(var i in r)y(n,i,{get:r[i],enumerable:!0})},F=(n,r,i,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let l of V(r))!w.call(n,l)&&l!==i&&y(n,l,{get:()=>r[l],enumerable:!(s=x(r,l))||s.enumerable});return n};var J=n=>F(y({},"__esModule",{value:!0}),n);var R=(n,r,i)=>(b(n,typeof r!="symbol"?r+"":r,i),i);var k={};j(k,{Ranges:()=>E,defaults:()=>N,version:()=>_});function $(n,r=1){let i="\xA0";function s(e){return Array.from(e).reverse().join("")}function l(e,u,o){let a=o?`
`:"\r",t=o?"\r":`
`;if(!e)return e;let O=0,d=0,f="";for(let g=0,C=e.length;g<C;g++)(e[g]===a||e[g]===t&&e[g-1]!==a)&&d++,`\r
`.includes(e[g])||e[g]===i?(O=0,e[g]===i?f+=e[g]:e[g]===a?d<=u&&(f+=e[g],e[g+1]===t&&(f+=e[g+1],g++)):e[g]===t&&(e==null?void 0:e[g-1])!==a&&d<=u&&(f+=e[g])):(O++,!e[g+1]&&!d&&(f+=" "));return f}if(typeof n=="string"&&n.length){let e=1;typeof+r=="number"&&Number.isInteger(+r)&&+r>=0&&(e=+r);let u="",o="";if(!n.trim())u=n;else if(!n[0].trim()){for(let a=0,t=n.length;a<t;a++)if(n[a].trim()){u=n.slice(0,a);break}}if(n.trim()&&(n.slice(-1).trim()===""||n.slice(-1)===i)){for(let a=n.length;a--;)if(n[a].trim()){o=n.slice(a+1);break}}return`${l(u,e,!1)}${n.trim()}${s(l(s(o),e,!0))}`}return n}function h(n){return typeof n=="string"}function c(n){return Number.isSafeInteger(n)&&n>=0}function m(n){return n!=null}var L={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function T(n,r){if(!Array.isArray(n)||!n.length)return n;let i=p(p({},L),r),s,l;if(i.strictlyTwoElementsInRangeArrays&&!n.every((o,a)=>!Array.isArray(o)||o.length!==2?(s=a,l=o.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${s}th range (${JSON.stringify(n[s],null,4)}) has not two but ${l} elements!`);if(!n.every((o,a)=>!Array.isArray(o)||!Number.isInteger(o[0])||o[0]<0||!Number.isInteger(o[1])||o[1]<0?(s=a,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${s}th range (${JSON.stringify(n[s],null,4)}) does not consist of only natural numbers!`);let e=n.length**2,u=0;return Array.from(n).sort((o,a)=>(i.progressFn&&(u+=1,i.progressFn(Math.floor(u*100/e))),o[0]===a[0]?o[1]<a[1]?-1:o[1]>a[1]?1:0:o[0]<a[0]?-1:1))}var D="7.0.8";var S={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function v(n,r){function i(t){return!!t&&typeof t=="object"&&!Array.isArray(t)}if(!Array.isArray(n)||!n.length)return null;let s;if(r)if(i(r)){if(s=p(p({},S),r),s.progressFn&&i(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&typeof s.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] resolvedOpts.progressFn must be a function! It was given of a type: "${typeof s.progressFn}", equal to ${JSON.stringify(s.progressFn,null,4)}`);if(![1,2,"1","2"].includes(s.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] resolvedOpts.mergeType was customised to a wrong thing! It was given of a type: "${typeof s.mergeType}", equal to ${JSON.stringify(s.mergeType,null,4)}`);if(typeof s.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] resolvedOpts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof s.joinRangesThatTouchEdges}", equal to ${JSON.stringify(s.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(r,null,4)} (type ${typeof r})`);else s=p({},S);let l=n.filter(t=>Array.isArray(t)).map(t=>[...t]).filter(t=>t[2]!==void 0||t[0]!==t[1]),e,u,o;s.progressFn?e=T(l,{progressFn:t=>{o=Math.floor(t/5),o!==u&&(u=o,s.progressFn(o))}}):e=T(l);let a=e.length-1;for(let t=a;t>0;t--)s.progressFn&&(o=Math.floor((1-t/a)*78)+21,o!==u&&o>u&&(u=o,s.progressFn(o))),(e[t][0]<=e[t-1][0]||!s.joinRangesThatTouchEdges&&e[t][0]<e[t-1][1]||s.joinRangesThatTouchEdges&&e[t][0]<=e[t-1][1])&&(e[t-1][0]=Math.min(e[t][0],e[t-1][0]),e[t-1][1]=Math.max(e[t][1],e[t-1][1]),e[t][2]!==void 0&&(e[t-1][0]>=e[t][0]||e[t-1][1]<=e[t][1])&&e[t-1][2]!==null&&(e[t][2]===null&&e[t-1][2]!==null?e[t-1][2]=null:e[t-1][2]!=null?+s.mergeType==2&&e[t-1][0]===e[t][0]?e[t-1][2]=e[t][2]:e[t-1][2]+=e[t][2]:e[t-1][2]=e[t][2]),e.splice(t,1),t=e.length);return e.length?e:null}var _=D,N={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},E=class{constructor(r){R(this,"ranges");R(this,"opts");let i=p(p({},N),r);if(i.mergeType&&i.mergeType!==1&&i.mergeType!==2)if(h(i.mergeType)&&i.mergeType.trim()==="1")i.mergeType=1;else if(h(i.mergeType)&&i.mergeType.trim()==="2")i.mergeType=2;else throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof i.mergeType}", equal to ${JSON.stringify(i.mergeType,null,4)}`);this.opts=i,this.ranges=[]}add(r,i,s){var u;if(r==null&&i==null)return;if(m(r)&&!m(i)){if(Array.isArray(r)){if(r.length){if(r.some(o=>Array.isArray(o))){r.forEach(o=>{Array.isArray(o)&&this.add(...o)});return}r.length&&c(+r[0])&&c(+r[1])&&this.add(...r)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(r,null,0)}) but second-one, "to" is not (${JSON.stringify(i,null,0)})`)}else if(!m(r)&&m(i))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(i,null,0)}) but first-one, "from" is not (${JSON.stringify(r,null,0)})`);let l=+r,e=+i;if(c(s)&&(s=String(s)),c(l)&&c(e)){if(m(s)&&!h(s)&&!c(s))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof s}, equal to:
${JSON.stringify(s,null,4)}`);if(m(this.ranges)&&Array.isArray(this.last())&&l===this.last()[1]){if(this.last()[1]=e,this.last()[2],this.last()[2]!==null&&m(s)){let o=this.last()[2]&&this.last()[2].length&&(!((u=this.opts)!=null&&u.mergeType)||this.opts.mergeType===1)?`${this.last()[2]}${s}`:s;this.opts.limitToBeAddedWhitespace&&(o=$(o,this.opts.limitLinebreaksCount)),h(o)&&!o.length||(this.last()[2]=o)}}else{this.ranges||(this.ranges=[]);let o=s!==void 0&&!(h(s)&&!s.length)?[l,e,s&&this.opts.limitToBeAddedWhitespace?$(s,this.opts.limitLinebreaksCount):s]:[l,e];this.ranges.push(o)}}else throw c(l)&&l>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof e}" equal to: ${JSON.stringify(e,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof l}" equal to: ${JSON.stringify(l,null,4)}`)}push(r,i,s){this.add(r,i,s)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=v(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(r=>m(r[2])?[r[0],r[1],$(r[2],this.opts.limitLinebreaksCount)]:r):this.ranges):null}wipe(){this.ranges=[]}replace(r){if(Array.isArray(r)&&r.length)if(Array.isArray(r[0])&&c(r[0][0]))this.ranges=Array.from(r);else throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(r[0],null,4)} should be an array and its first element should be an integer, a string index.`);else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};return J(k);})();
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 7.0.5
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */
/**
 * @name codsen-utils
 * @fileoverview Various utility functions
 * @version 1.4.0
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/codsen-utils/}
 */
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 6.0.7
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
